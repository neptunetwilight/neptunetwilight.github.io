<!DOCTYPE html><html lang="zh-tw"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="TwilightCoder"><meta name="renderer" content="webkit"><meta name="copyright" content="TwilightCoder"><meta name="keywords" content="Twilight's blog"><meta name="description" content="neptunetwilight study blog"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>用Java实现八大排序算法 · Twilight's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Twilight's blog" type="application/atom+xml">
</head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/ailise.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">TwilightCoder</div><div class="profile-signature">stay cool</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/ruanguohui" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/63292959_p0.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Twilight's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">用Java实现八大排序算法</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021-02-05 19:37:17</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="数据算法与结构"> 数据算法与结构</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">5.9k</span> | Reading time: <span class="post-count">24</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h2 id="一、冒泡排序-Bubblesort"><a href="#一、冒泡排序-Bubblesort" class="headerlink" title="一、冒泡排序(Bubblesort):"></a>一、冒泡排序(Bubblesort):</h2><h3 id="原理-Principle"><a href="#原理-Principle" class="headerlink" title="原理(Principle):"></a>原理(Principle):</h3><ul>
<li>冒泡排序是比较简单的排序算法，它循环走过需要排序的元素，依次比较相邻的两个元素，如果顺序错误就交换，直至没有元素交换，完成排序。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity"><a href="#时间复杂度-Time-Complexity" class="headerlink" title="时间复杂度(Time Complexity):"></a>时间复杂度(Time Complexity):</h3><ul>
<li>冒泡排序是一种用时间换空间的排序方法，最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序。在这种情况下，每一次比较都需要进行交换运算。好比我们对n个人进行排序，若两两间需要比较一次则比较次数为n-1次，那么进行一次冒泡排序的比较次数就会变成（n-1）+（n-2）+…+1=n*（n-1）/2，因此冒泡排序的时间复杂度为O(n^2)。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n²)</td>
<td align="center">O(n)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img"><a href="#图示说明-Img" class="headerlink" title="图示说明(Img):"></a>图示说明(Img):</h3><p><img src="https://images.morethink.cn/bubble.gif" alt="Bubblesort"></p>
<h3 id="代码-code"><a href="#代码-code" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传统冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp; <span class="comment">//定义临时变量用于交换时的临时存放</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">/*这里让i=arr数组长度进行倒序输出，</span></span><br><span class="line"><span class="comment">			因为冒泡排序正着输出顺序为从大到小*/</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					temp=arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//进行输出</span></span><br><span class="line">		<span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">59</span>,<span class="number">64</span>,<span class="number">15</span>,<span class="number">35</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">86</span>,<span class="number">15</span>,<span class="number">45</span>&#125;;</span><br><span class="line">		bubblesort.bubble(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总的来说冒泡排序是一种简单易于理解的排序算法，而且是稳定的算法，冒泡排序的一个改进是，在内层循环之前设置一个标记变量，用于标记循环是否进行了交换，在内层循环结束时，若判断没有进行交换，则说明剩下的序列中，每个元素都小于等于后面一个元素，即已经有序，可终止循环。这样，冒泡排序的最好时间复杂度可以提升到O(n)。</li>
</ul>
<hr>
<h2 id="二、插入排序-Insertsort"><a href="#二、插入排序-Insertsort" class="headerlink" title="二、插入排序(Insertsort):"></a>二、插入排序(Insertsort):</h2><h3 id="原理-Principle-："><a href="#原理-Principle-：" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>插入排序相当于人们在打扑克牌时整理牌序，通常我们将其中混乱的单张牌插入有序的牌中，为了要给插入的牌腾出空间，那么其后的牌需要给插入的牌位置因而需要后移。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-："><a href="#时间复杂度-Time-Complexity-：" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li>最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n²)</td>
<td align="center">O(n)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-："><a href="#图示说明-Img-：" class="headerlink" title="图示说明(Img)："></a>图示说明(Img)：</h3><p><img src="https://images.morethink.cn/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif" alt="Insertsort"></p>
<h3 id="代码-code-1"><a href="#代码-code-1" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertsort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//从零开始遍历需要循环的次数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;<span class="comment">//内部进行循环比较交换，将大的元素与小的元素进行位置交换</span></span><br><span class="line">				<span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;<span class="comment">//循环比较直到后一个元素比前一个元素大为止</span></span><br><span class="line">					<span class="keyword">int</span> temp=arr[j];</span><br><span class="line">					arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">					arr[j-<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//进行输出</span></span><br><span class="line">		<span class="keyword">int</span>[] arr=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">38</span>,<span class="number">44</span>,<span class="number">47</span>,<span class="number">46</span>,<span class="number">26</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>,<span class="number">27</span>&#125;;</span><br><span class="line">		insertsort.insert(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入排序所需要的时间取决于元素初始的排位顺序，如同刚刚所讲的最好情况和最坏情况，但是这中间用到的是元素的交换位置进行的排序而不是元素的后移。</li>
</ul>
<p><strong>元素后移代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> num = arr2[i];<span class="comment">//num赋予从下标i开始循环的值</span></span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; num &lt; arr2[j - <span class="number">1</span>]; j--) &#123;<span class="comment">//数组中下标为j-1的值（也就是i-1）若大于刚才赋予的num里的下标所对应的i的值</span></span><br><span class="line">			arr2[j] = arr2[j - <span class="number">1</span>];<span class="comment">//将下标j-1的值赋予了下标为j的位置也就完成了一次后移然后进行循环</span></span><br><span class="line">		&#125;</span><br><span class="line">		arr2[j] = num;<span class="comment">//因为j--的缘故现在j为原来j-1赋予了num的值</span></span><br><span class="line">	&#125;            </span><br></pre></td></tr></table></figure>
<ul>
<li>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。插入排序还可进行各种修改使得算法更加快捷，可进行二分插入排序也可修改成希尔排序</li>
</ul>
<hr>
<h2 id="三、希尔排序-Shellsort"><a href="#三、希尔排序-Shellsort" class="headerlink" title="三、希尔排序(Shellsort):"></a>三、希尔排序(Shellsort):</h2><h3 id="原理-Principle-1"><a href="#原理-Principle-1" class="headerlink" title="原理(Principle):"></a>原理(Principle):</h3><ul>
<li>希尔排序，也称 递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是 非稳定排序算法。希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-1"><a href="#时间复杂度-Time-Complexity-1" class="headerlink" title="时间复杂度(Time Complexity):"></a>时间复杂度(Time Complexity):</h3><ul>
<li>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog2n)</td>
<td align="center">O(n)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-1"><a href="#图示说明-Img-1" class="headerlink" title="图示说明(Img):"></a>图示说明(Img):</h3><p><img src="https://images.morethink.cn/4697893fd8a952d01956e192640c1c3c.png" alt="Shellsort"></p>
<h3 id="代码-code-2"><a href="#代码-code-2" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shellsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;<span class="comment">//给数组分组，每次步长为2</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i-gap;j&gt;=<span class="number">0</span>;j-=gap)&#123;<span class="comment">//遍历各组中所有元素,j-=gap是用于和上一个分组内元素作比较</span></span><br><span class="line">					<span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123;<span class="comment">//如果当前元素大于加上步长后的元素，则交换</span></span><br><span class="line">						temp=arr[j];</span><br><span class="line">						arr[j]=arr[j+gap];</span><br><span class="line">						arr[j+gap]=temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span>[] arr=&#123;<span class="number">0</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">			shellsort.shellsort(arr);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是希尔排序的交换算法，但是这种操作并不是最好，反而在进行大量数据排序时比它的原型插入排序还慢，因此需要和插入排序一样进行移位而不是交换计算。</li>
</ul>
<p><strong>后移的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort2</span><span class="params">(<span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> gap=arr2.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr2.length;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i;</span><br><span class="line">			<span class="keyword">int</span> temp=arr2[j];</span><br><span class="line">			<span class="keyword">if</span>(arr2[j]&lt;arr2[j-gap])&#123;</span><br><span class="line">				<span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr2[j-gap])&#123;</span><br><span class="line">					arr2[j]=arr2[j-gap];</span><br><span class="line">					j-=gap;</span><br><span class="line">				&#125;</span><br><span class="line">				arr2[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、归并排序-Mergesort"><a href="#四、归并排序-Mergesort" class="headerlink" title="四、归并排序(Mergesort):"></a>四、归并排序(Mergesort):</h2><h3 id="原理-Principle-：-1"><a href="#原理-Principle-：-1" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。它是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-：-1"><a href="#时间复杂度-Time-Complexity-：-1" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li>归并的时间复杂度分析：主要考虑两个函数的时间花销，一、数组划分函数 二、有序数组归并函数<br>前者的时间复杂度为O（n）,因为代码中有2个长度为n的循环，所以时间复杂度为O（n）；<br>数组长度为n的归并排序所消耗的时间T[n]：调用前面函数将数组划分为两个部分，那每一个部分排序好所花时间为T[n/2]，最后将这两个部分的数组合并成一个有序数组的时间花费为O(n);</li>
</ul>
<p>公式：T[n]=2T[n/2]+O(n);</p>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-：-1"><a href="#图示说明-Img-：-1" class="headerlink" title="图示说明(Img)："></a>图示说明(Img)：</h3><p><img src="/img/sort/1024555-20161218163120151-452283750.png" alt="Example"></p>
<p><img src="https://images.morethink.cn/merging-sort.gif" alt="Mergesort"></p>
<h3 id="代码-code-3"><a href="#代码-code-3" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergesort</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 原数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left	分组时候的左边部分索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid	中间部分索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right	右边部分索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp 临时存放数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//分+合并</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesorted</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">			<span class="comment">//向左进行递归分解(递归)</span></span><br><span class="line">			mergesorted(arr,left,mid,temp);</span><br><span class="line">			<span class="comment">//向右(递归)</span></span><br><span class="line">			mergesorted(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">			<span class="comment">//调用合并</span></span><br><span class="line">			merge(arr,left,mid,right,temp);</span><br><span class="line">		&#125;</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=left;<span class="comment">//初始化 i，左边有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> j=mid+<span class="number">1</span>;<span class="comment">//初始化j，右边有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> t=<span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line">		<span class="comment">//上述索引可理解为指针(想成c/c++比较易于理解。。。个人看法)</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先把左右两边开始填充，直到一边填充完毕为止</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">				temp[t]=arr[i];</span><br><span class="line">				t+=<span class="number">1</span>;</span><br><span class="line">				i+=<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">//反之如果右边小于左边的的元素，填充右边的</span></span><br><span class="line">				temp[t]=arr[j];</span><br><span class="line">				t+=<span class="number">1</span>;</span><br><span class="line">				j+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把剩余的数填充到辅助数组中去</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">			temp[t]=arr[i];</span><br><span class="line">			t+=<span class="number">1</span>;</span><br><span class="line">			i+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">			temp[t]=arr[j];</span><br><span class="line">			t+=<span class="number">1</span>;</span><br><span class="line">			j+=<span class="number">1</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从辅助数组中拷贝数据到原数组，☞最后一次</span></span><br><span class="line">		t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tempLeft=left;</span><br><span class="line">		<span class="keyword">while</span>(tempLeft&lt;=right)&#123;</span><br><span class="line">			arr[tempLeft]=temp[t];</span><br><span class="line">			t+=<span class="number">1</span>;</span><br><span class="line">			tempLeft+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">23</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//归并需要一个额外辅助数组</span></span><br><span class="line">		mergesorted(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, temp);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</li>
</ul>
<hr>
<h2 id="五、快速排序-Quicksort"><a href="#五、快速排序-Quicksort" class="headerlink" title="五、快速排序(Quicksort):"></a>五、快速排序(Quicksort):</h2><h3 id="原理-Principle-：-2"><a href="#原理-Principle-：-2" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-：-2"><a href="#时间复杂度-Time-Complexity-：-2" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li> 快速排序涉及到递归调用，所以该算法的时间复杂度还需要从递归算法的复杂度开始说起， 递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)，快速排序最优的情况就是每一次取到的元素都刚好平分整个数组；<br>此时的时间复杂度公式则为：T[n] = 2T[n/2] + f(n)；T[n/2]为平分后的子数组的时间复杂度，f[n] 为平分这个数组时所花的时间，快速排序最优的情况下时间复杂度为：O( nlogn )<br>最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)，这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O( n^2 )</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-：-2"><a href="#图示说明-Img-：-2" class="headerlink" title="图示说明(Img)："></a>图示说明(Img)：</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Example"></p>
<p><img src="/img/sort/quick.gif" alt="Quicksort"></p>
<h3 id="代码-code-4"><a href="#代码-code-4" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quicksort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = a[low];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">			<span class="comment">//从后往前开始比较，直到遇到比pivot小的数,将其移到low位置,此时high位置的数在[]中有两个</span></span><br><span class="line">			<span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=pivot) high--;</span><br><span class="line">			a[low] = a[high];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//再从前开始比较，当然第一个a[low]是刚移过来的，low++,直到遇到比pivot小的数,将其替换到high位置的值</span></span><br><span class="line">			<span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=pivot) low++;</span><br><span class="line">			a[high]=a[low];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历到后来low&gt;high时，结束</span></span><br><span class="line">		a[low] = pivot;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">			<span class="keyword">int</span> pivot = partition(data,low,high);</span><br><span class="line">			quickSort(data,low,pivot-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			quickSort(data,pivot+<span class="number">1</span>,high);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		quicksort t = <span class="keyword">new</span> quicksort();</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">			a[i]=(<span class="keyword">int</span>)(Math.random()*<span class="number">100000</span>)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t.quickSort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : a)</span><br><span class="line">			System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速排序由于排序效率在同为 O(nlogn) 的几种排序方法中效率最高，因此经常被采用。再加上快速排序思想——分治法也确实非常实用，所以 在各大厂的面试习题中，快排总是最耀眼的那个。它的时间复杂度与选取基准数密不可分，因而还衍生出了各种基准数的选取方法，有固定基准数、随机基准数、三数取中等方法，还需要去认真学习</li>
</ul>
<hr>
<h2 id="六、选择排序-Selectsort"><a href="#六、选择排序-Selectsort" class="headerlink" title="六、选择排序(Selectsort):"></a>六、选择排序(Selectsort):</h2><h3 id="原理-Principle-：-3"><a href="#原理-Principle-：-3" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-：-3"><a href="#时间复杂度-Time-Complexity-：-3" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li>选择排序的复杂度分析。第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较1次。共比较的次数是 (N - 1) + (N - 2) + … + 1，求等差数列和，得 (N - 1 + 1)* N / 2 = N^2 / 2。舍去最高项系数，其时间复杂度为 O(N^2)。属于不稳定算法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O( n^2 )</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-：-3"><a href="#图示说明-Img-：-3" class="headerlink" title="图示说明(Img)："></a>图示说明(Img)：</h3><p><img src="https://images.morethink.cn/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif" alt="Selectsort"></p>
<h3 id="代码-code-5"><a href="#代码-code-5" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> min = i;</span><br><span class="line">			<span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//最小值不等于当前值时进行交换</span></span><br><span class="line">			<span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = a[i];</span><br><span class="line">				a[i] = a[min];</span><br><span class="line">				a[min] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] arr=&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">11</span>&#125;;</span><br><span class="line">		sort(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</li>
</ul>
<hr>
<h2 id="七、堆排序-Heapsort"><a href="#七、堆排序-Heapsort" class="headerlink" title="七、堆排序(Heapsort):"></a>七、堆排序(Heapsort):</h2><h3 id="原理-Principle-：-4"><a href="#原理-Principle-：-4" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>堆其实相当于一个完全二叉树，那么堆的含义就是：完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。 由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-：-4"><a href="#时间复杂度-Time-Complexity-：-4" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li>初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)。另外堆排序的比较次数和序列的初始状态有关，但只是在序列初始状态为堆的情况下比较次数显著减少，在序列有序或逆序的情况下比较次数不会发生明显变化。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<h3 id="图示说明-Img-：-4"><a href="#图示说明-Img-：-4" class="headerlink" title="图示说明(Img)："></a>图示说明(Img)：</h3><p><img src="https://images.morethink.cn/heap_sort_gif.gif" alt="Heapsort"></p>
<h3 id="代码-code-6"><a href="#代码-code-6" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> []arr = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">18</span>,<span class="number">778</span>,<span class="number">145</span>,<span class="number">99</span>&#125;;</span><br><span class="line">			System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">			sort(arr);</span><br><span class="line">			System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">			<span class="comment">//1.构建大顶堆</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				<span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">				adjustHeap(arr,i,arr.length);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">				adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">			&#125;</span><br><span class="line">	 </span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">				<span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">					arr[i] = arr[k];</span><br><span class="line">					i = k;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 交换元素</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=arr[a];</span><br><span class="line">			arr[a] = arr[b];</span><br><span class="line">			arr[b] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</li>
</ul>
<hr>
<h2 id="八、基数排序-Radixsort"><a href="#八、基数排序-Radixsort" class="headerlink" title="八、基数排序(Radixsort):"></a>八、基数排序(Radixsort):</h2><h3 id="原理-Principle-：-5"><a href="#原理-Principle-：-5" class="headerlink" title="原理(Principle)："></a>原理(Principle)：</h3><ul>
<li>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
</ul>
<p><strong>基数排序按照优先从高位或低位来排序有两种实现方案：</strong></p>
<ul>
<li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序：</strong>先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p>
</li>
<li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序：</strong> 先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p>
</li>
</ul>
<h3 id="时间复杂度-Time-Complexity-：-5"><a href="#时间复杂度-Time-Complexity-：-5" class="headerlink" title="时间复杂度(Time Complexity)："></a>时间复杂度(Time Complexity)：</h3><ul>
<li>对于给定的n个d位数，取值范围为[0,k]，我们使用计数排序比较元素的每一位，基数排序耗时Θ(n+k)，那么基数排序的复杂度为Θ(d(n+k))。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(d*(n+r))</td>
<td align="center">O(d*(n+r))</td>
<td align="center">O(d*(n+r))</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<p><img src="https://images.morethink.cn/radix-sort_sample.gif" alt="Radixsort"></p>
<h3 id="代码-code-7"><a href="#代码-code-7" class="headerlink" title="代码(code):"></a>代码(code):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 各位装通法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		<span class="keyword">int</span> length = n;</span><br><span class="line">		<span class="keyword">int</span> divisor = <span class="number">1</span>;<span class="comment">// 定义每一轮的除数，1,10,100...</span></span><br><span class="line">		<span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];<span class="comment">// 定义了10个桶，以防每一位都一样全部放入一个桶中</span></span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">// 统计每个桶中实际存放的元素个数</span></span><br><span class="line">		<span class="keyword">int</span> digit;<span class="comment">// 获取元素中对应位上的数字，即装入那个桶</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;<span class="comment">// 经过4次装通操作，排序完成</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> temp : A) &#123;<span class="comment">// 计算入桶</span></span><br><span class="line">				digit = (temp / divisor) % <span class="number">10</span>;</span><br><span class="line">				bucket[digit][count[digit]++] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 被排序数组的下标</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">10</span>; b++) &#123;<span class="comment">// 从0到9号桶按照顺序取出</span></span><br><span class="line">				<span class="keyword">if</span> (count[b] == <span class="number">0</span>)<span class="comment">// 如果这个桶中没有元素放入，那么跳过</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; count[b]; w++) &#123;</span><br><span class="line">					A[k++] = bucket[b][w];</span><br><span class="line">				&#125;</span><br><span class="line">				count[b] = <span class="number">0</span>;<span class="comment">// 桶中的元素已经全部取出，计数器归零</span></span><br><span class="line">			&#125;</span><br><span class="line">			divisor *= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] a=&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">65</span>,<span class="number">156</span>,<span class="number">77</span>,<span class="number">98</span>&#125;;</span><br><span class="line">		radixSort(a,a.length);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基数排序更适合用于对时间, 字符串等这些 整体权值未知的数据 进行排序。基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</li>
</ul>
<hr>
<p><strong>参考资料：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/morethink/p/8419151.html">morethink的博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haozhengfei/p/29ba40edbf659f2dbc6b429c2818c594.html">日月的弯刀的博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35580883/article/details/79114134">TimeTDIT的CSDN</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://neptunetwilight.github.io">TwilightCoder</a></p><p> <span>Link:  </span><a href="https://neptunetwilight.github.io/2021/01/31/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">https://neptunetwilight.github.io/2021/01/31/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/02/05/Spring%E5%92%8CSpring-mvc%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/" title="Spring和Spring-mvc框架原理以及应用"><span>< PreviousPost</span><br><span class="prevTitle">Spring和Spring-mvc框架原理以及应用</span></a><a class="nextSlogan" href="/2021/01/27/hello-world/" title="Hello World"><span>NextPost ></span><br><span class="nextTitle">Hello World</span></a><div class="clear"></div></div><div id="comment"></div></section></article><div id="musicMouseDrag" style="position:fixed; z-index: 9999; bottom: 0; right: 0;"><div id="musicDragArea" style="position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;"></div><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script></div><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?" + 'var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?800f627451dc58b62e719fdfcbf4c40e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();';
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubblesort"><span class="toc-number">1.</span> <span class="toc-text">一、冒泡排序(Bubblesort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle"><span class="toc-number">1.1.</span> <span class="toc-text">原理(Principle):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity"><span class="toc-number">1.2.</span> <span class="toc-text">时间复杂度(Time Complexity):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img"><span class="toc-number">1.3.</span> <span class="toc-text">图示说明(Img):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code"><span class="toc-number">1.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertsort"><span class="toc-number">2.</span> <span class="toc-text">二、插入排序(Insertsort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">图示说明(Img)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-1"><span class="toc-number">2.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shellsort"><span class="toc-number">3.</span> <span class="toc-text">三、希尔排序(Shellsort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-1"><span class="toc-number">3.1.</span> <span class="toc-text">原理(Principle):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-1"><span class="toc-number">3.2.</span> <span class="toc-text">时间复杂度(Time Complexity):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-1"><span class="toc-number">3.3.</span> <span class="toc-text">图示说明(Img):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-2"><span class="toc-number">3.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Mergesort"><span class="toc-number">4.</span> <span class="toc-text">四、归并排序(Mergesort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A-1"><span class="toc-number">4.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A-1"><span class="toc-number">4.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-%EF%BC%9A-1"><span class="toc-number">4.3.</span> <span class="toc-text">图示说明(Img)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-3"><span class="toc-number">4.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quicksort"><span class="toc-number">5.</span> <span class="toc-text">五、快速排序(Quicksort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A-2"><span class="toc-number">5.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A-2"><span class="toc-number">5.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-%EF%BC%9A-2"><span class="toc-number">5.3.</span> <span class="toc-text">图示说明(Img)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-4"><span class="toc-number">5.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selectsort"><span class="toc-number">6.</span> <span class="toc-text">六、选择排序(Selectsort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A-3"><span class="toc-number">6.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A-3"><span class="toc-number">6.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-%EF%BC%9A-3"><span class="toc-number">6.3.</span> <span class="toc-text">图示说明(Img)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-5"><span class="toc-number">6.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-Heapsort"><span class="toc-number">7.</span> <span class="toc-text">七、堆排序(Heapsort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A-4"><span class="toc-number">7.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A-4"><span class="toc-number">7.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E-Img-%EF%BC%9A-4"><span class="toc-number">7.3.</span> <span class="toc-text">图示说明(Img)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-6"><span class="toc-number">7.4.</span> <span class="toc-text">代码(code):</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radixsort"><span class="toc-number">8.</span> <span class="toc-text">八、基数排序(Radixsort):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-Principle-%EF%BC%9A-5"><span class="toc-number">8.1.</span> <span class="toc-text">原理(Principle)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-Time-Complexity-%EF%BC%9A-5"><span class="toc-number">8.2.</span> <span class="toc-text">时间复杂度(Time Complexity)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-code-7"><span class="toc-number">8.3.</span> <span class="toc-text">代码(code):</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":300,"hOffset":60,"vOffset":0},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>